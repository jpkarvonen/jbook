{"ast":null,"code":"import getSurroundingWord from './getSurroundingWord';\nexport function selectWord(_ref) {\n  var text = _ref.text,\n      selection = _ref.selection;\n\n  if (text && text.length && selection.start === selection.end) {\n    // the user is pointing to a word\n    return getSurroundingWord(text, selection.start);\n  }\n\n  return selection;\n}\n/**\n *  Gets the number of line-breaks that would have to be inserted before the given 'startPosition'\n *  to make sure there's an empty line between 'startPosition' and the previous text\n */\n\nexport function getBreaksNeededForEmptyLineBefore() {\n  var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n  var startPosition = arguments.length > 1 ? arguments[1] : undefined;\n  if (startPosition === 0) return 0; // rules:\n  // - If we're in the first line, no breaks are needed\n  // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\n  //      may need to insert 0, 1 or 2 breaks\n\n  var neededBreaks = 2;\n  var isInFirstLine = true;\n\n  for (var i = startPosition - 1; i >= 0 && neededBreaks >= 0; i--) {\n    switch (text.charCodeAt(i)) {\n      case 32:\n        // blank space\n        continue;\n\n      case 10:\n        // line break\n        neededBreaks--;\n        isInFirstLine = false;\n        break;\n\n      default:\n        return neededBreaks;\n    }\n  }\n\n  return isInFirstLine ? 0 : neededBreaks;\n}\n/**\n *  Gets the number of line-breaks that would have to be inserted after the given 'startPosition'\n *  to make sure there's an empty line between 'startPosition' and the next text\n */\n\nexport function getBreaksNeededForEmptyLineAfter() {\n  var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n  var startPosition = arguments.length > 1 ? arguments[1] : undefined;\n  if (startPosition === text.length - 1) return 0; // rules:\n  // - If we're in the first line, no breaks are needed\n  // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\n  //      may need to insert 0, 1 or 2 breaks\n\n  var neededBreaks = 2;\n  var isInLastLine = true;\n\n  for (var i = startPosition; i < text.length && neededBreaks >= 0; i++) {\n    switch (text.charCodeAt(i)) {\n      case 32:\n        continue;\n\n      case 10:\n        {\n          neededBreaks--;\n          isInLastLine = false;\n          break;\n        }\n\n      default:\n        return neededBreaks;\n    }\n  }\n\n  return isInLastLine ? 0 : neededBreaks;\n}","map":{"version":3,"mappings":"AACA,OAAOA,kBAAP,MAA+B,sBAA/B;AAOA,OAAO,SAASC,UAAT,OAAiE;AAAA,MAA3CC,IAA2C,QAA3CA,IAA2C;AAAA,MAArCC,SAAqC,QAArCA,SAAqC;;AACtE,MAAID,IAAI,IAAIA,IAAI,CAACE,MAAbF,IAAuBC,SAAS,CAACE,KAAVF,KAAoBA,SAAS,CAACG,GAAzD,EAA8D;AAC5D;AACA,WAAON,kBAAkB,CAACE,IAAD,EAAOC,SAAS,CAACE,KAAjB,CAAzB;AACD;;AACD,SAAOF,SAAP;AACD;AAED;AACA;AACA;AACA;;AACA,OAAO,SAASI,iCAAT,GAAqF;AAAA,MAA1CL,IAA0C,uEAAnC,EAAmC;AAAA,MAA/BM,aAA+B;AAC1F,MAAIA,aAAa,KAAK,CAAtB,EAAyB,OAAO,CAAP,CADiE,CAG1F;AACA;AACA;AACA;;AAEA,MAAIC,YAAY,GAAG,CAAnB;AACA,MAAIC,aAAa,GAAG,IAApB;;AACA,OAAK,IAAIC,CAAC,GAAGH,aAAa,GAAG,CAA7B,EAAgCG,CAAC,IAAI,CAALA,IAAWF,YAAY,IAAI,CAA3D,EAA+DE,CAAC,EAAhE,EAAoE;AAClE,YAAQT,IAAI,CAACU,UAALV,CAAgBS,CAAhBT,CAAR;AACE,WAAK,EAAL;AAAS;AACP;;AACF,WAAK,EAAL;AAAS;AACPO,oBAAY;AACZC,qBAAa,GAAG,KAAhBA;AACA;;AACF;AACE,eAAOD,YAAP;AARJ;AAUD;;AACD,SAAOC,aAAa,GAAG,CAAH,GAAOD,YAA3B;AACD;AAED;AACA;AACA;AACA;;AACA,OAAO,SAASI,gCAAT,GAAoF;AAAA,MAA1CX,IAA0C,uEAAnC,EAAmC;AAAA,MAA/BM,aAA+B;AACzF,MAAIA,aAAa,KAAKN,IAAI,CAACE,MAALF,GAAc,CAApC,EAAuC,OAAO,CAAP,CADkD,CAGzF;AACA;AACA;AACA;;AAEA,MAAIO,YAAY,GAAG,CAAnB;AACA,MAAIK,YAAY,GAAG,IAAnB;;AACA,OAAK,IAAIH,CAAC,GAAGH,aAAb,EAA4BG,CAAC,GAAGT,IAAI,CAACE,MAATO,IAAoBF,YAAY,IAAI,CAAhE,EAAoEE,CAAC,EAArE,EAAyE;AACvE,YAAQT,IAAI,CAACU,UAALV,CAAgBS,CAAhBT,CAAR;AACE,WAAK,EAAL;AACE;;AACF,WAAK,EAAL;AAAS;AACPO,sBAAY;AACZK,sBAAY,GAAG,KAAfA;AACA;AACD;;AACD;AACE,eAAOL,YAAP;AATJ;AAWD;;AACD,SAAOK,YAAY,GAAG,CAAH,GAAOL,YAA1B;AACD","names":["getSurroundingWord","selectWord","text","selection","length","start","end","getBreaksNeededForEmptyLineBefore","startPosition","neededBreaks","isInFirstLine","i","charCodeAt","getBreaksNeededForEmptyLineAfter","isInLastLine"],"sources":["/Users/karvonen/Valet/udemy-port/jbook/packages/local-client/node_modules/@uiw/react-md-editor/src/utils/markdownUtils.ts"],"sourcesContent":["import { TextRange } from '../commands';\nimport getSurroundingWord from './getSurroundingWord';\n\nexport interface TextSection {\n  text: string;\n  selection: TextRange;\n}\n\nexport function selectWord({ text, selection }: TextSection): TextRange {\n  if (text && text.length && selection.start === selection.end) {\n    // the user is pointing to a word\n    return getSurroundingWord(text, selection.start);\n  }\n  return selection;\n}\n\n/**\n *  Gets the number of line-breaks that would have to be inserted before the given 'startPosition'\n *  to make sure there's an empty line between 'startPosition' and the previous text\n */\nexport function getBreaksNeededForEmptyLineBefore(text = \"\", startPosition: number): number {\n  if (startPosition === 0) return 0;\n\n  // rules:\n  // - If we're in the first line, no breaks are needed\n  // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\n  //      may need to insert 0, 1 or 2 breaks\n\n  let neededBreaks = 2;\n  let isInFirstLine = true;\n  for (let i = startPosition - 1; i >= 0 && (neededBreaks >= 0); i--) {\n    switch (text.charCodeAt(i)) {\n      case 32: // blank space\n        continue;\n      case 10: // line break\n        neededBreaks--;\n        isInFirstLine = false;\n        break;\n      default:\n        return neededBreaks;\n    }\n  }\n  return isInFirstLine ? 0 : neededBreaks;\n}\n\n/**\n *  Gets the number of line-breaks that would have to be inserted after the given 'startPosition'\n *  to make sure there's an empty line between 'startPosition' and the next text\n */\nexport function getBreaksNeededForEmptyLineAfter(text = \"\", startPosition: number): number {\n  if (startPosition === text.length - 1) return 0;\n\n  // rules:\n  // - If we're in the first line, no breaks are needed\n  // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\n  //      may need to insert 0, 1 or 2 breaks\n\n  let neededBreaks = 2;\n  let isInLastLine = true;\n  for (let i = startPosition; i < text.length && (neededBreaks >= 0); i++) {\n    switch (text.charCodeAt(i)) {\n      case 32:\n        continue;\n      case 10: {\n        neededBreaks--;\n        isInLastLine = false;\n        break;\n      }\n      default:\n        return neededBreaks;\n    }\n  }\n  return isInLastLine ? 0 : neededBreaks;\n}\n"]},"metadata":{},"sourceType":"module"}