{"ast":null,"code":"/**\n * The MIT License\n * Copyright (c) 2018 Dmitriy Kubyshkin\n * Copied from https://github.com/grassator/insert-text-at-cursor\n */\nvar browserSupportsTextareaTextNodes;\n/**\n * @param {HTMLElement} input\n * @return {boolean}\n */\n\nfunction canManipulateViaTextNodes(input) {\n  if (input.nodeName !== \"TEXTAREA\") {\n    return false;\n  }\n\n  if (typeof browserSupportsTextareaTextNodes === \"undefined\") {\n    var textarea = document.createElement('textarea');\n    textarea.value = '1';\n    browserSupportsTextareaTextNodes = !!textarea.firstChild;\n  }\n\n  return browserSupportsTextareaTextNodes;\n}\n/**\n * @param {HTMLTextAreaElement|HTMLInputElement} input\n * @param {string} text\n * @returns {void}\n */\n\n\nexport default (function (input, text) {\n  // Most of the used APIs only work with the field selected\n  input.focus(); // IE 8-10\n\n  if (document.selection) {\n    var ieRange = document.selection.createRange();\n    ieRange.text = text; // Move cursor after the inserted text\n\n    ieRange.collapse(false\n    /* to the end */\n    );\n    ieRange.select();\n    return;\n  } // Webkit + Edge\n\n\n  var isSuccess = document.execCommand('insertText', false, text);\n\n  if (!isSuccess) {\n    var start = input.selectionStart;\n    var end = input.selectionEnd; // Firefox (non-standard method)\n\n    if (typeof input.setRangeText === \"function\") {\n      input.setRangeText(text);\n    } else {\n      // To make a change we just need a Range, not a Selection\n      var range = document.createRange();\n      var textNode = document.createTextNode(text);\n\n      if (canManipulateViaTextNodes(input)) {\n        var node = input.firstChild; // If textarea is empty, just insert the text\n\n        if (!node) {\n          input.appendChild(textNode);\n        } else {\n          // Otherwise we need to find a nodes for start and end\n          var offset = 0;\n          var startNode = null;\n          var endNode = null;\n\n          while (node && (startNode === null || endNode === null)) {\n            var nodeLength = node.nodeValue.length; // if start of the selection falls into current node\n\n            if (start >= offset && start <= offset + nodeLength) {\n              range.setStart(startNode = node, start - offset);\n            } // if end of the selection falls into current node\n\n\n            if (end >= offset && end <= offset + nodeLength) {\n              range.setEnd(endNode = node, end - offset);\n            }\n\n            offset += nodeLength;\n            node = node.nextSibling;\n          } // If there is some text selected, remove it as we should replace it\n\n\n          if (start !== end) {\n            range.deleteContents();\n          }\n        }\n      } // If the node is a textarea and the range doesn't span outside the element\n      //\n      // Get the commonAncestorContainer of the selected range and test its type\n      // If the node is of type `#text` it means that we're still working with text nodes within our textarea element\n      // otherwise, if it's of type `#document` for example it means our selection spans outside the textarea.\n\n\n      if (canManipulateViaTextNodes(input) && range.commonAncestorContainer.nodeName === '#text') {\n        // Finally insert a new node. The browser will automatically split start and end nodes into two if necessary\n        range.insertNode(textNode);\n      } else {\n        // If the node is not a textarea or the range spans outside a textarea the only way is to replace the whole value\n        var value = input.value;\n        input.value = value.slice(0, start) + text + value.slice(end);\n      }\n    } // Correct the cursor position to be at the end of the insertion\n\n\n    input.setSelectionRange(start + text.length, start + text.length); // Notify any possible listeners of the change\n\n    var e = document.createEvent(\"UIEvent\");\n    e.initEvent(\"input\", true, false);\n    input.dispatchEvent(e);\n  }\n});","map":{"version":3,"mappings":"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","names":["browserSupportsTextareaTextNodes","canManipulateViaTextNodes","input","nodeName","textarea","document","createElement","value","firstChild","text","focus","selection","ieRange","createRange","collapse","select","isSuccess","execCommand","start","selectionStart","end","selectionEnd","setRangeText","range","textNode","createTextNode","node","appendChild","offset","startNode","endNode","nodeLength","nodeValue","length","setStart","setEnd","nextSibling","deleteContents","commonAncestorContainer","insertNode","slice","setSelectionRange","e","createEvent","initEvent","dispatchEvent"],"sources":["/Users/karvonen/Valet/udemy-port/jbook/node_modules/@uiw/react-md-editor/src/utils/InsertTextAtPosition.ts"],"sourcesContent":["/**\n * The MIT License\n * Copyright (c) 2018 Dmitriy Kubyshkin\n * Copied from https://github.com/grassator/insert-text-at-cursor\n */\n\nlet browserSupportsTextareaTextNodes: any;\n\n/**\n * @param {HTMLElement} input\n * @return {boolean}\n */\nfunction canManipulateViaTextNodes(input: HTMLTextAreaElement | HTMLInputElement) {\n  if (input.nodeName !== \"TEXTAREA\") {\n    return false;\n  }\n  if (typeof browserSupportsTextareaTextNodes === \"undefined\") {\n    const textarea: HTMLTextAreaElement = document.createElement('textarea');\n    textarea.value = '1';\n    browserSupportsTextareaTextNodes = !!textarea.firstChild;\n  }\n  return browserSupportsTextareaTextNodes;\n}\n\n/**\n * @param {HTMLTextAreaElement|HTMLInputElement} input\n * @param {string} text\n * @returns {void}\n */\nexport default (input: HTMLTextAreaElement | HTMLInputElement, text: string) => {\n  // Most of the used APIs only work with the field selected\n  input.focus();\n\n  // IE 8-10\n  if ((document as any).selection) {\n    const ieRange = (document as any).selection.createRange();\n    ieRange.text = text;\n\n    // Move cursor after the inserted text\n    ieRange.collapse(false /* to the end */);\n    ieRange.select();\n\n    return;\n  }\n\n  // Webkit + Edge\n  const isSuccess = document.execCommand('insertText', false, text);\n  if (!isSuccess) {\n    const start = input.selectionStart!;\n    const end = input.selectionEnd!;\n    // Firefox (non-standard method)\n    if (typeof input.setRangeText === \"function\") {\n      input.setRangeText(text);\n    } else {\n      // To make a change we just need a Range, not a Selection\n      const range = document.createRange();\n      const textNode = document.createTextNode(text);\n\n      if (canManipulateViaTextNodes(input)) {\n        let node = input.firstChild;\n\n        // If textarea is empty, just insert the text\n        if (!node) {\n          input.appendChild(textNode);\n        } else {\n          // Otherwise we need to find a nodes for start and end\n          let offset = 0;\n          let startNode = null;\n          let endNode = null;\n\n          while (node && (startNode === null || endNode === null)) {\n            const nodeLength = node.nodeValue!.length;\n\n            // if start of the selection falls into current node\n            if (start >= offset && start <= offset + nodeLength) {\n              range.setStart((startNode = node), start - offset);\n            }\n\n            // if end of the selection falls into current node\n            if (end >= offset && end <= offset + nodeLength) {\n              range.setEnd((endNode = node), end - offset);\n            }\n\n            offset += nodeLength;\n            node = node.nextSibling;\n          }\n\n          // If there is some text selected, remove it as we should replace it\n          if (start !== end) {\n            range.deleteContents();\n          }\n        }\n      }\n\n      // If the node is a textarea and the range doesn't span outside the element\n      //\n      // Get the commonAncestorContainer of the selected range and test its type\n      // If the node is of type `#text` it means that we're still working with text nodes within our textarea element\n      // otherwise, if it's of type `#document` for example it means our selection spans outside the textarea.\n      if (canManipulateViaTextNodes(input) && range.commonAncestorContainer.nodeName === '#text') {\n        // Finally insert a new node. The browser will automatically split start and end nodes into two if necessary\n        range.insertNode(textNode);\n      } else {\n        // If the node is not a textarea or the range spans outside a textarea the only way is to replace the whole value\n        const value = input.value;\n        input.value = value.slice(0, start) + text + value.slice(end);\n      }\n    }\n\n    // Correct the cursor position to be at the end of the insertion\n    input.setSelectionRange(start + text.length, start + text.length);\n\n    // Notify any possible listeners of the change\n    const e = document.createEvent(\"UIEvent\");\n    e.initEvent(\"input\", true, false);\n    input.dispatchEvent(e);\n  }\n}"]},"metadata":{},"sourceType":"module"}